Code "Smash over Loopkick" in "My changes" by "Me" does "Does what it says"
//
     #lib "Sonic"
//
{
     Sonic.State.Redirect(Sonic.StateID.StateLoopKick, Sonic.StateID.StateSmash)
}

Code "LoopKick over Smash" in "My changes" by "Me" does "Does what it says" 
//
     #lib "Sonic"
//
{
     Sonic.State.Redirect(Sonic.StateID.StateSmash, Sonic.StateID.StateLoopKick)
}

Code "Dropdash Roll over Spindash with hold" in "My changes" by "Weezley" does "Allows you to use the dropdash when you try spindashing. Due to not giving itself it's own velocity, it works as a roll" 
//
     #lib "Sonic"
//
{
    Sonic.State.Redirect(Sonic.StateID.StateSpinBoost, Sonic.StateID.StateDropDash)

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateSpinBoost && Sonic.Input.IsReleased(Sonic.PlayerActionType.PlayerSonicboom))
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateRun : Sonic.StateID.StateFall)
    }
}

Code "Dropdash Roll over Spindash with hold" in "My changes" by "Weezley" does "Allows you to use the dropdash when you try spindashing. Due to not giving itself it's own velocity, it works as a roll" 
//
     #lib "Sonic"
//
{
    Sonic.State.Redirect(Sonic.StateID.StateSpinMove, Sonic.StateID.StateDropDash)

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateSpinMove && Sonic.Input.IsReleased(Sonic.PlayerActionType.PlayerSonicboom))
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateRun : Sonic.StateID.StateFall)
    }
}

Code "Dropdash Roll over Spindash with hold" in "My changes" by "Weezley" does "Allows you to use the dropdash when you try spindashing. Due to not giving itself it's own velocity, it works as a roll" 
//
     #lib "Sonic"
//
{
    Sonic.State.Redirect(Sonic.StateID.StateDropDash, Sonic.StateID.StateDropDash)

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateDropDash && Sonic.Input.IsReleased(Sonic.PlayerActionType.PlayerSonicboom))
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateRun : Sonic.StateID.StateFall)
    }
}

Code "Dropdash Roll over Spindash with hold" in "My changes" by "Weezley" does "Allows you to use the dropdash when you try spindashing. Due to not giving itself it's own velocity, it works as a roll" 
//
     #lib "Sonic"
//
{
    Sonic.State.Redirect(Sonic.StateID.StateSpinBoost, Sonic.StateID.StateDropDash)

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateSpinBoost && Sonic.Input.IsReleased(Sonic.PlayerActionType.PlayerSonicboom))
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateRun : Sonic.StateID.StateFall)
    }
}

Code "Dropdash Roll over Spindash with hold" in "My changes" by "Weezley" does "Allows you to use the dropdash when you try spindashing. Due to not giving itself it's own velocity, it works as a roll" 
//
     #lib "Sonic"
//
{
    Sonic.State.Redirect(Sonic.StateID.StateSpinMove, Sonic.StateID.StateDropDash)

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateSpinMove && Sonic.Input.IsReleased(Sonic.PlayerActionType.PlayerSonicboom))
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateRun : Sonic.StateID.StateFall)
    }
}

Code "Dropdash Roll over Spindash with hold" in "My changes" by "Weezley" does "Allows you to use the dropdash when you try spindashing. Due to not giving itself it's own velocity, it works as a roll" 
//
     #lib "Sonic"
//
{
    Sonic.State.Redirect(Sonic.StateID.StateDropDash, Sonic.StateID.StateDropDash)

    if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateDropDash && Sonic.Input.IsReleased(Sonic.PlayerActionType.PlayerSonicboom))
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateRun : Sonic.StateID.StateFall)
    }
}

Code "Drop Dash Over Spin Dash" in "Gameplay" by "Weezley" 
//
	#include "ReflectionHelpers" noemit

    #lib "Sonic"
	#lib "SonicParameters"
    #lib "BlackboardStatus"

    static bool IsVelocityAdded = false;
    static float chargeCount = 0.0f;
//
{
    Sonic.State.Redirect(Sonic.StateID.StateSpinBoost, Sonic.StateID.StateDropDash);

    var currentState = Sonic.State.GetCurrentStateID();
    var previousState = Sonic.State.GetPreviousStateID();

    if (!Sonic.IsGrounded() && BlackboardStatus.IsCyberSpace())
    {
        Sonic.State.Discard(Sonic.StateID.StateSpinBoostCharge);
    }
    else
    {
        Sonic.State.Restore(Sonic.StateID.StateSpinBoostCharge);
    }

    if (!Sonic.IsGrounded() && !BlackboardStatus.IsCyberSpace())
    {
        Sonic.State.Redirect(Sonic.StateID.StateSpinBoostCharge, Sonic.StateID.StateSonicBoomKick)
    }
    else
    {
        Sonic.State.Redirect(Sonic.StateID.StateSpinBoostCharge, Sonic.StateID.StateSpinBoostCharge)
    }

    if (Sonic.Kinematics.GetHorizontalMagnitude() >= 30.0f) 
    {
	Sonic.State.Discard(Sonic.StateID.StateSpinBoostCharge)
    }

    if (Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerSonicboom) && Sonic.State.GetCurrentStateID() == Sonic.StateID.StateSpinBoostCharge && chargeCount < 12)
    {
        chargeCount += 1;
    }
    else if (Sonic.State.GetCurrentStateID() == Sonic.StateID.StateSpinBoostCharge && chargeCount < 12)
    {
        chargeCount += 0.066f;
    }

    if (previousState == Sonic.StateID.StateSpinBoostCharge && currentState == Sonic.StateID.StateSpinBoost)
    {
        if (!IsVelocityAdded && !BlackboardStatus.IsCyberSpace() && !Sonic.IsSideView())
        {
            var kinematics = Sonic.Kinematics.Get();

            if (kinematics == null)
                return;

            *kinematics.Velocity += Sonic.Kinematics.GetForward() * (chargeCount * 2.5f + 10.0f);

            IsVelocityAdded = true;

            goto Reset;
        }

        if (!IsVelocityAdded && BlackboardStatus.IsCyberSpace() && !Sonic.IsSideView())
        {
            var kinematics = Sonic.Kinematics.Get();

            if (kinematics == null)
                return;

            *kinematics.Velocity += Sonic.Kinematics.GetForward() * (chargeCount * 2.0f + 5.0f);

            IsVelocityAdded = true;

            goto Reset;
        }

	if (!IsVelocityAdded && Sonic.IsSideView())
        {
            var kinematics = Sonic.Kinematics.Get();

            if (kinematics == null)
                return;

            *kinematics.Velocity += Sonic.Kinematics.GetForward() * (chargeCount * 1.0f + 10.0f);

            IsVelocityAdded = true;

            goto Reset;
        }
        Reset:
            chargeCount = 0;
    }
    else
    {
        IsVelocityAdded = false;
    }

    if (Sonic.State.GetCurrentStateID() != Sonic.StateID.StateSpinBoostCharge)
    {
        chargeCount = 1;
    }

    bool isBoostPressed = Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerBoost);
    bool isStompPressed = Sonic.Input.IsPressed(Sonic.PlayerActionType.PlayerStomping);

    if ((currentState == Sonic.StateID.StateSpinBoost || currentState == Sonic.StateID.StateDropDash) && isStompPressed)
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateSpringJumpHeadLand : Sonic.StateID.StateFall);
    }
    else if ((currentState == Sonic.StateID.StateSpinBoost || currentState == Sonic.StateID.StateDropDash) && isBoostPressed)
    {
        Sonic.State.SetState(Sonic.IsGrounded() ? Sonic.StateID.StateAirBoost : Sonic.StateID.StateBumpJump);
    }

    if (Sonic.IsSideView())
    {
        WriteProtected<byte>
        (
            ScanSignature
            (
                "\x74\x10\x0F\x28\xCF",
                "xxxxx"
            ),

            0xEB
        )
    }
    else
    {
        WriteProtected<byte>
        (
            ScanSignature
            (
                "\x74\x10\x0F\x28\xCF",
                "xxxxx"
            ),

            0x74, 0x10, 0x0F, 0x28, 0xCF
        )
    }

    var SonicParametersInfo = Reflection.GetDataInfo<SonicParameters.Root>("player_common");

	if (SonicParametersInfo.pData == null)
		return;

	RFL_SET_PARAM(SonicParametersInfo, forwardView.dropDash.brake, 20.0f);
	RFL_SET_PARAM(SonicParametersInfo, forwardView.dropDash.steeringSpeed1, 360.0f);
	RFL_SET_PARAM(SonicParametersInfo, forwardView.dropDash.steeringSpeed2, 70.0f);
    RFL_SET_PARAM(SonicParametersInfo, forwardView.dropDash.checkDashSpeed, 3.0f);
    RFL_SET_PARAM(SonicParametersInfo, cyberspace.dropDash.brake, 20.0f);
	RFL_SET_PARAM(SonicParametersInfo, cyberspace.dropDash.steeringSpeed1, 360.0f);
	RFL_SET_PARAM(SonicParametersInfo, cyberspace.dropDash.steeringSpeed2, 60.0f);
    RFL_SET_PARAM(SonicParametersInfo, cyberspace.dropDash.checkDashSpeed, 3.0f);
    RFL_SET_PARAM(SonicParametersInfo, cyberspaceSV.dropDash.brake, 20.0f);
	RFL_SET_PARAM(SonicParametersInfo, cyberspaceSV.dropDash.steeringSpeed1, 400.0f);
	RFL_SET_PARAM(SonicParametersInfo, cyberspaceSV.dropDash.steeringSpeed2, 200.0f);
    RFL_SET_PARAM(SonicParametersInfo, cyberspaceSV.dropDash.checkDashSpeed, 3.0f);
}

Patch "Disable Drop Dash Turning Delay" in "Physics" by "Hyper"
{
    WriteNop
    (
        /* 0x14084323B */
        ScanSignature
        (
            "\x73\x19\x48\x8B\x47\x40",
            "xxxxxx"
        ),

        2
    );
}

Patch "Disable Power Boost" in "Gameplay" by "Hyper" 
{
    WriteProtected<byte>
    (
        /* 0x1408D27AA */
        ScanSignature
        (
            "\x74\x2A\x0F\xBE\x43\x30\x66\x0F\x6E\xC8\x0F\xBE\x43\x31\x0F\x5B\xC9\x66\x0F\x6E\xC0\x0F\x5B\xC0\xF3\x0F\x5C\xC8\x0F\x54\x0D\xCC\xCC\xCC\xCC\x0F\x2F\x0D\xCC\xCC\xCC\xCC\x77\x15\xBA\x32\x00\x00\x00\x48\x8B\xCE\xE8\xCC\xCC\xCC\xCC\x84\xC0\x74\x04\xB0\x01",
            "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx????xxx????xxxxxxxxxxx????xxxxxx"
        ),

        0xEB, 0x3F
    );
}

Code "Retain Ground Velocity for Jump" in "Physics" by "Hyper" does 
/*
Retains Sonic's ground velocity when jumping.

Notes;
- This will allow you to retain velocity when jumping out of a Drop Dash.
- The "Jump Deceleration" and "Maintain boost during a jump" options can remain active without conflicting with this code.
*/
//
    #lib "Memory"
    #lib "Sonic"

    static bool IsInitialised = false;
    static bool IsStateJump = false;
//
{
    if (!IsInitialised)
    {
        fixed (bool* pIsStateJump = &IsStateJump)
        {
            /* v1.30: 0x1408406F8 */
            var callerFuncAddr = ScanSignature
            (
                "\xE8\xCC\xCC\xCC\xCC\x48\x8B\x43\x20\xBA\x20\x16\x1E\x71\x44\x0F\x28\xC0\x48\x8B\x88\x80\x00\x00\x00\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xCB\x0F\x28\xF8\xE8\xCC\xCC\xCC\xCC\x48\x8B\xC8\xE8\xCC\xCC\xCC\xCC\x48\x8D\x55\xE7",
                "x????xxxxxxxxxxxxxxxxxxxxx????xxxx????xxxxxxx????xxxx????xxxx"
            );

            /* v1.30: 0x14080CA10 */
            var mainFuncAddr = Memory.ReadCall(callerFuncAddr);

            // Update posture to allow retaining ground velocity.
            WriteAsmHook
            (
                $@"
                    mov   rdi, rcx

                    ; Check if we're in the jump state
                    push  r11
                    mov   r11, {(long)pIsStateJump}
                    mov   r11b, byte ptr [r11]
                    cmp   r11b, 0
                    jz    default
                    mov   al, 1
                    jmp   exit

                default:
                    xor   edx, edx
                    mov   rcx, [rcx + 0x28] ; RCX = BlackboardStatus
                    mov   eax, edx
                    and   eax, 0x3F
                    movzx r8d, al
                    mov   eax, edx
                    shr   rax, 6
                    mov   rax, [rcx + rax * 8 + 0x30]
                    bt    rax, r8
                    setb  al

                exit:
                    pop   r11
                ",

                /* v1.30: 0x14080CA16 */
                mainFuncAddr + 6,

                HookBehavior.Replace
            );
        }

        IsInitialised = true;
    }

    void NotifyStateJump(Sonic.StateID stateId, Sonic.StateID[] stateStackTrace)
    {
        IsStateJump = (stateId == Sonic.StateID.StateJump) || (stateId == Sonic.StateID.StateGrindJump);
    }

    Sonic.State.AddStateNotifyAction(NotifyStateJump);
}